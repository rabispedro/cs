# cs

<h1>Conjunto de Habilidades de Programação em CS</h1>

<h2>Pontuação Referencial</h2>

1) Nunca ouvi falar sobre isso antes
2) Já ouvi falar, mas não conheço os detalhes
3) Conheço, mas ainda não programei/usei
4) Posso programar/usar, mas não com muita confiança ou rapidez
5) Posso programar/usar com rapidez e confiança

<h2>Estruturas de Dados, Algoritmos, & Palavras-Chave de Programação</h2>

1)  Conceitos Básicos de Programação: Sequência, Seleção, Repetição
1)  Recursão/Backtracking

1)  Problema Ad-Hoc

1)  C++ STL (Standard Template Library)
1)  Java API (Application Programming Interface)
1)  Array/C++ STL vector/Java Vector
1)  Técnicas Básicas de Bitmask, Manipulação de Bits
1)  Lista Encadeada/C++ STL list/Java LinkedList
1)  Pilha/Fila/Fila Dupla/C++ STL stack/queue/deque/Java Stack/Queue/Deque
1)  Árvore Binária de Busca/C++ STL map/set/Java TreeMap/TreeSet
1)  Árvore Binária Balanceada/AVL/Red-Black (com seu próprio código)
1)  Tabela Hash/Java HashMap (C++11 unordered_map)
1)  Heap/Fila de Prioridade/C++ STL priority_queue/Java PriorityQueue
1)  Grafo/Matriz de Adjacência/Lista de Adjacência/Lista de Arestas
1)  Conjuntos Disjuntos Union-Find
1)  Árvore de Segmentos
1)  Árvore Binária Indexada (BIT/Binary Indexed Tree/Árvore de Fenwick)

1)  Bubble Sort
1)  Insertion Sort
1)  Selection Sort
1)  Merge Sort
1)  Quick Sort
1)  Heap Sort
1)  Ordenação com Vários Campos (ex.: ordenação com Struct, Classes)
1)  Counting Sort
1)  Contagem de Inversões (com Merge Sort)

1)  Busca Completa/Força Bruta/Backtracking Recursivo/Iterativo
1)  Consigo resolver o problema das N-Rainhas até N ≤ 14 (N-Queens Problem)
1)  Busca em Espaço de Estados (State-Space Search)
1)  Meet in the Middle (Busca Bidirecional)
1)  Algoritmo A* (tradicional)
1)  Técnica de Aprofundamento Iterativo (IDA*)

1)  Princípios de Divisão & Conquista
1)  Técnicas de Busca Binária

1)  Gulosos

1)  Ideias Básicas de Programação Dinâmica (PD)
1)  Soma Máxima 1D/2D/etc
1)  Algoritmo de Kadane para Soma Máxima 1D/2D/etc
1)  Longest Increasing Subsequence (LIS/Maior Subsequência Crescente)
1)  Solução em tempo O(n log k) para LIS
1)  Coin Change (CC/Problema do Troco)
1)  Algoritmo da Mochila 0-1/Soma de Subconjuntos (Subset Sum)
1)  Problema do Caixeiro Viajante (Traveling Salesman Problem/TSP)
1)  PD e sua relação com DAGs (Grafos Direcionados Acíclicos)
1)  PD "em Árvore"
1)  Longest Common Subsequence (LCS/Maior Subsequência Comum)
1)  Alinhamento de Strings/Distância de Edição
1)  Técnicas de Otimização de PD
1)  Caixeiro Viajante Bitônico (Bitonic TSP)
1)  Multiplicação de Cadeia de Matrizes (Matrix Chain Multiplication/MCM)
1)  Árvore Binária de Busca Ótima (Optimal Binary Search Tree/OBST)

1)  Busca/Percurso em Profundidade (Depth-First Search/DFS)
1)  Ordenação Topológica
1)  Encontrar Componentes Conectadas/Flood Fill
1)  Encontrar Pontos de Articulação/Pontes em tempo O(V+E)
1)  Encontrar Comp. Fortemente Conectadas (SCC) num Grafo Dirigido em O(V+E)
1)  Busca/Percurso em Amplitude (Breadth-First Search/DFS)
1)  Kruskal (Árvore Geradora Mínima/Minimum Spanning Tree/MST)
1)  Prim (Árvore Geradora Mínima/Minimum Spanning Tree/MST)
1)  Dijkstra (Caminho Mínimo de Fonte Única)
1)  Bellman Ford (Caminho Mínimo de Fonte Única)
1)  Floyd Warshall (Caminho Mínimo entre Todos os Pares)
1)  Ford Fulkerson/Edmonds Karp (Fluxo Máximo, Corte Mínimo)
1)  Caminhos Independentes e Arestas-Disjuntos
1)  Fluxo (Máximo) a Custo Mínimo
1)  Caminhos menores/maiores/entre Todos os Pares em uma Árvore
1)  Menor Ancestral Comum (Lowest Common Ancestor/LCA)
1)  Grafo/Caminho/Ciclo Euleriano
1)  Problema do Carteiro Chinês
1)  Grafo Direcionado Acíclico (Directed Acyclic Graph/DAG)
1)  Caminho Mínimo/Máximo em DAGs
1)  Contando Caminhos em DAGs
1)  Cobertura do Menor Caminho (Min Path Cover) em DAGs
1)  Grafo Bipartido
1)  Emparelhamento Máximo em Grafos Bipartidos (MCBM)
1)  Cobertura Mínima de Vértices em Grafos Bipartidos (Teorema de Konig)
1)  Maior Conjunto Independente/Dominante em Grafos Bipartidos
1)  Algoritmo de Caminho Aumentante p/ Emp. Máximo em Grafos Bipartidos
1)  Algoritmo de Hopcroft–Karp p/ Emp. Máximo em Grafos Bipartidos
1)  Algoritmo Kuhn Munkres/Húngaro p/ Emp. Máximo em Grafos Bipartidos
1)  Algoritmo de Edmonds (Blossom Shrinking) para Emparelhamento Geral

1)  Sequências e Sistemas de Numeração
1)  Polinômios
1)  Big Integer
1)  Número Base
1)  Combinatória
1)  Fatorial/Fibonacci
1)  Teoria dos Números
1)  Geração de Números Primos: Crivo de Eratóstenes
1)  Teste de Primos
1)  Algoritmo de Miller–Rabin
1)  Fatoração de Primos por Divisão por Tentativa
1)  Algoritmo Rho de Pollard (Pollard's Rho)
1)  Crivo Modificado
1)  MDC/MMC/Algoritmo de Euclides
1)  Euclides Estendido/Equação Linear Diofantina
1)  Phi de Euler
1)  Aritmética Modular
1)  Fibonacci/Factorial
1)  Divisibilidade
1)  Detecção de Ciclos/Algoritmo de Tortoise–Hare
1)  Exponenciação Rápida via Divisão & Conquista
1)  Exponenciação de Matrizes
1)  Álgebra Linear/Eliminação Gaussiana

1)  Gramáticas BNF (Forma(lismo) de Backus–Naur
1)  Algoritmo Knuth–Morris–Pratt (KMP) para Correspondência de Strings
1)  Aho–Corasick
1)  Trie de Sufixos e suas aplicações
1)  Árvore de Sufixos e suas aplicações
1)  Construção de Array de Sufixos em tempo O(n log n) e Aplicações

1)  Geometria Básica, ex.: área, perímetro, distância Euclidiana, Trigonometria
1)  Intersecção entre Segmentos de Reta
1)  Teste do Sentido Anti-Horário (CCW Test)
1)  Teste do Incírculo
1)  Área e Perímetro de um Polígono Arbitrário
1)  Testar se um Polígono é Convexo
1)  Testar se um Ponto está dentro de um Polígono
1)  Cortar um Polígono (Convexo) com uma Linha Reta
1)  Varredura de Graham (Fecho Convexo)
1)  Paradigma da Varredura no Plano
1)  Intersecção de Área ou Volume
1)  Triangulação
1)  Problema dos Pares Mais Próximos

1)  Estatísticas de Ordem: Algoritmo de Seleção em Tempo Linear
1)  Jogos clássicos de Tabuleiro, Cartas, Xadrez, jogos populares de Intelig. Artificial
1)  Ambiente e sistema operacional (Ubuntu) Linux
